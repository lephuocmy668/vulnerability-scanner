### 1. Project Overview
This project is a vulnerability scanner that detects security vulnerabilities in public Git repositories. The project consists of a web application that allows clients to submit tasks for repository scanning, and a worker that handles these tasks by scanning the repositories and generating a report.

#### 1.1 Non-functional requirements/Architecture Characteristics
The following non-functional requirements and architecture characteristics were taken into consideration during the design of this system:

**Scalability**: The system should be designed to handle a high volume of requests and be able to scale horizontally to meet increasing demand.

**Reliability**: The system should be highly available and resilient to failures.

**Security**: The system should be designed with security in mind and implement appropriate measures to protect against potential vulnerabilities.

**Performance**: The system should be designed to deliver fast response times and minimize latency.

**Maintainability**: The system should be easy to maintain and modify as requirements change over time.

**Testability**: The system should be designed to support automated testing and provide comprehensive test coverage.

**Modularity**: The system should be composed of loosely-coupled, highly-cohesive modules that can be developed and deployed independently.

**Extensibility**: The system should be designed to support future extensions and new features without requiring significant changes to the existing codebase.

#### 1.2 Design Principles
The following design principles were used in the development of this project:

**Think big, start small, learn fast**: We started with a minimal viable product and designed the architecture to be scalable and extensible in the future. This allowed us to focus on the essential features of the system while keeping the architecture flexible enough to accommodate future needs. We also made sure to learn from user feedback and continuously improve the system.

**Evolution by design**: We designed the system to evolve over time, using architecture patterns and design principles that enable us to add new features and functionality without introducing technical debt or disrupting the system's stability.

**Design for time-based outcomes**: We designed the system to deliver outcomes that align with our customers' needs and preferences, ensuring that we can respond quickly to changing market conditions and user expectations.

**Separation of Concerns**: We separated the project into different layers to ensure each layer has a specific responsibility and performs a specific set of functions. This ensures that the system is modular, easy to test, and maintain.

**Domain-Driven Design (DDD)**: We used DDD principles to design the domain model and business logic, ensuring that the domain objects and rules were at the core of the system design. This allowed us to create a flexible and adaptable system that can accommodate changes in the business requirements.

**Clean Architecture**: We used the Clean Architecture principles to design the system, which ensures that the business logic is independent of the technology stack used to implement the system. This enables us to swap out different components of the system without affecting the overall architecture.

**SOLID Principles**: We followed the SOLID principles, which are a set of object-oriented design principles, to ensure that the code is maintainable, scalable, and easy to extend.

By following these design principles, we have created a system that is flexible, scalable, and easy to maintain. We also have a continuous improvement mindset, which allows us to learn from user feedback and make changes to the system accordingly.

### 2. Solution Design and Scope
#### 2.1 Solution Diagram with Use-case flow

1> Submit task:
- The client submits a task to the TaskMgmt API.
- The TaskMgmt API stores the task in the database (1.1).
- The TaskMgmt API publishes a TaskCreated event with the task ID (1.2).
- The TaskMgmt API returns the task information to the client (1.3).

2> Get task detail:
- The client requests the details of a single task from the TaskMgmt API.
- The TaskMgmt API retrieves the task information from the database (2.1).
- The TaskMgmt API returns the task information to the client (2.3).

3> Get task list:
- The client requests a list of tasks from the TaskMgmt API.
- The TaskMgmt API retrieves the task list from the database (3.1).
- The TaskMgmt API returns the task list to the client (3.3).

Task processing:
When a TaskCreated event is received by the NATS message broker (1.4), a worker consumes the event (1.5).
The worker applies the rule engine to process the task in the background.
After processing, the worker stores the task result in the database (1.6).
```lua
+-------+          +------------+         +--------+       +---------+        +------+
|Client |          |  TaskMgmt  |         |Database|       |  NATS   |        |Worker|
+-------+          +------------+         +--------+       +---------+        +------+
    |                   |                     |                  |                 |
    |                   |                     |                  |                 |
    |  1. Submit task   |                     |                  |                 |
    |------------------>|                     |                  |                 |
    |                   | 1.1 Store task to DB|                  |                 |
    |                   |-------------------->|                  |                 |
    |                   |                     |                  |                 |
    |                   |        1.2 Publish TaskCreated event   |                 |
    |                   |- - - - - - - - - - - - - - - - - - - ->|                 |
    |                   |                     |                  |                 |
    | 1.3 Return TaskInfo                     |                  |                 |
    |<------------------|                     |                  |                 |
    |                   |                     |                  |                 |
    |                   |                     |                  |1.4 Consumer     |
    |                   |                     |                  |TaskCreated event|
    |                   |                     |                  |<- - - - - - - - |
    |                   |                     |                  |                 |            
    |                   |                     |                  |                 |------
    |                   |                     |                  |                 |      |  1.5 Handle task in background by appling rule engine
    |                   |                     |                  |                 |<-----
    |                   |                     |     1.6 Store Task Result to DB    |
    |                   |                     |<-----------------------------------|                 
    |                   |                     |                  |                 |
    |                   |                     |                  |                 |
    |                   |                     |                  |                 |
    | 2. Get task detail|                     |                  |                 |
    |------------------>|                     |                  |                 |
    |                   | 2.1 Get single task |                  |                 |
    |                   |-------------------->|                  |                 |
    |                   |                     | 2.2 Fetch task   |                 |
    |                   |                     | from DB          |                 |
    |                   |                     |<-----------------|                 |
    |2.3 Return TaskInfo|                     |                  |                 |
    |<------------------|                     |                  |                 |
    |                   |                     |                  |                 |
    |                   |                     |                  |                 |
    | 3. Get task list  |                     |                  |                 |
    |------------------>|                     |                  |                 |
    |                   | 3.1 Get task list   |                  |                 |
    |                   |-------------------->|                  |                 |
    |                   |                     | 3.2 Fetch task   |                 |
    |                   |                     | list from DB     |                 |
    |                   |                     |<-----------------|                 |
    |2.3 Return task list                     |                  |                 |
    |<------------------|                     |                  |                 |
    |                   |                     |                  |                 |
 

```

#### 2.2 Solution Scope
The solution includes a web application that allows clients to submit tasks for repository scanning. When a task is submitted, the web application stores the task in a database and publishes a message to a message broker. A worker listens for messages from the message broker and handles tasks by scanning the repositories and generating a report. The report is then stored in the database and can be retrieved by clients.

#### 2.3 Out of Scope
Authentication and authorization are out of scope for this project.

### 3. Design Elaboration
#### 3.1 Receive task
When a client submits a task for repository scanning, the web application validates the repository URL to ensure that it is valid. If the repository URL is valid, the web application creates a task in the database and publishes a message to a message broker.

#### 3.2 Check task status and result:
We enable users to use the API to get the task detail in order to check the scan result and status.
When the client sends a GET request to the TaskMgmtAPI at "/tasks/{task_id}", the TaskMgmtAPI will query the database to retrieve the task record with the specified "task_id" from the "scanning_tasks" table. Then, it will return the task record to the client in the response.

#### 3.3 Get task list:
When the client sends a GET request to the TaskMgmtAPI at "/tasks", the TaskMgmtAPI will query the database to retrieve all the task records from the "scanning_tasks" table. Then, it will return a list of all the task records to the client in the response.

#### 3.4 Handle task by worker
The worker listens for messages from the message broker and when a new task message is received, it retrieves the task from the database and performs the scanning of the repository. Once the scanning is complete, the worker generates a report and stores it in the database.

### 4. Design Considerations

#### 4.1 Assumptions
- The solution assumes that the repositories being scanned are public Git repositories.
- The system assumes that the rule engine can process tasks in a reasonable amount of time.

#### 4.2 Risks
- The scanning process may be resource-intensive and may require dedicated hardware or cloud resources.
- The use of a message broker introduces a single point of failure.
- The scanning process may take a long time to complete, depending on the size of the repository being scanned.
- Worker nodes might fail, requiring a system to ensure high availability and fault tolerance.
- We are using the single database for both service(TaskMgmt and Worker) so database performance might be a bottleneck if the system has a high volume of requests.
- NATS might experience downtime or connectivity issues, causing message loss or delay.
- Worker nodes might fail, requiring a system to ensure high availability and fault tolerance.

#### 4.3 Issues
- The worker may be subject to rate limiting by Git providers.
- There might be security risks associated with storing sensitive data in the database.
- The complexity of the system might make it difficult to troubleshoot and maintain.

#### 4.4 Dependencies
- The system is dependent on NATS to handle message delivery reliably and efficiently.
- The system is dependent on the database to store and retrieve task data quickly and efficiently.

#### 4.5 Implications/Considerations
- The system might require a load balancer to distribute incoming requests across multiple worker nodes for improved performance and scalability.
- The system might require a monitoring solution to ensure high availability and to detect and resolve issues quickly.
- The system might require a disaster recovery plan to ensure data recovery in the event of a system failure or outage.

#### 4.3 Infrastructure - Deployment View

```lua
                            +---------------+
                            |  Load Balancer|
                            +-------+-------+
                                    |
                                    |
+--------------------------------------------------------------------------+ 
|                                                                          |
|  +-------+  +-------+  +-------+  |  |  +-------+  +-------+  +-------+  |  
|  | App   |  | App   |  | App   |  |  |  | App   |  | App   |  | App   |  |  
|  |Server |  |Server |  |Server |  |  |  |Server |  |Server |  |Server |  | 
|  +-------+  +-------+  +-------+  |  |  +-------+  +-------+  +-------+  |  
|                                                                          |
|                           EKS/ECS Service                                |
|                                                                          |
+--------------------------------------------------------------------------+
                           |                            |
        +------------------------------------+  +----------------+
        |     NATS Messaging System          |  |      Database  |
        +------------------------------------+  +----------------+
                           |                            |
+--------------------------------------------------------------------------+
|                                                                          |
|       +-------------+       +-------------+        +-------------+       |
|       | Scan Worker |       | Scan Worker |        | Scan Worker |       |
|       +-------------+       +-------------+        +-------------+       |       
|                                                                          |
|                            EKS/ECS Service                               |
|                                                                          |
+--------------------------------------------------------------------------+
```

#### 4.4 API Design
The web application exposes a RESTful API with the following endpoints:

##### POST `/tasks`
Create a new scanning task.

Request body:
```lua
{
    "repository_name": "string",
    "repository_url": "string"
}

```

Response body:

```lua
{
    "task": {
        "id": "string",
        "status": "string",
        "repository_name": "string",
        "repository_url": "string",
        "created_at": "string",
        "updated_at": "string",
        "started_at": "string",
        "completed_at": "string",
        "error": "string"
    }
}
```

##### GET `/tasks`
Get a list of all scanning tasks.

Response body:
```lua
{
    "tasks": [
        {
            "id": "string",
            "status": "string",
            "repository_name": "string",
            "repository_url": "string",
            "created_at": "string",
            "updated_at": "string",
            "started_at": "string",
            "completed_at": "string",
            "error": "string"
        }
    ]
}

```

#### GET `/tasks/{id}`
Get details of a single scanning task by ID.

Response body:
```lua
{
    "task": {
        "id": "string",
        "status": "string",
        "repository_name": "string",
        "repository_url": "string",
        "findings": [
            {
                "type": "string",
                "rule_id": "string",
                "location": {
                    "path": "string",
                    "begin": {
                        "line": "number"
                    }
                },
                "metadata": {
                    "description": "string",
                    "severity": "string"
                }
            }
        ],
        "created_at": "string",
        "updated_at": "string",
        "started_at": "string",
        "completed_at": "string",
        "error": "string"
    }
}
```
#### Error Responses
##### 400 Bad Request

If the request is invalid or missing required parameters, the response will be:
```lua
{
    "error": "string"
}
```
##### 404 Not Found

If the requested resource does not exist, the response will be:

```lua
{
    "error": "string"
}
```

##### 500 Internal Server Error

If the server encounters an error while processing the request, the response will be:

```lua
{
    "error": "string"
}
```

#### 4.5 Event Schema Design
The following events are published by the web application:
```lua
{
  "type": "string",
  "description": "ID of the queued task"
}
```

#### 4.6 Database Schema Design
The following tables are included in the database schema:
```lua
+------------------------+             +-------------------------+
| scanning_tasks         |             | vulnerabilities         |
|------------------------|             |-------------------------|
| id      UUID           | 1------->N  | id           SERIAL     |
| status  TEXT           |             | scanning_task_id UUID   |
| repo    TEXT           |             | type         TEXT       |
| url     TEXT           |             | rule_id      TEXT       |
| created_at TIMESTAMP   |             | path         TEXT       |
| updated_at TIMESTAMP   |             | line         INTEGER    |
| deleted_at TIMESTAMP   |             | description  TEXT       |
| started_at TIMESTAMP   |             | severity     TEXT       |
| completed_at TIMESTAMP |             | created_at   TIMESTAMP  |
| error   TEXT           |             | updated_at   TIMESTAMP  |
|                        |             | deleted_at   TIMESTAMP  |
+------------------------+             +-------------------------+
```
scanning_tasks - stores information about each task, including the repository URL, status, and scan results
vulnerabilities - stores information about each finding in a scan result, including the file path and vulnerability info

#### 4.7 Project Structure

```lua
.
├── Dockerfile
├── README.md
├── cmd
│   └── main.go
├── docker-compose.yaml
├── domain
│   ├── constants.go
│   ├── domain.go
│   ├── errors.go
│   ├── model.go
│   ├── publisher.go
│   ├── repositories.go
│   ├── rules
│   │   ├── hardcoded_secret_rule.go
│   │   ├── hardcoded_secret_rule_test.go
│   │   └── rules.go
│   ├── scanner_service.go
│   ├── scanner_service_test.go
│   ├── scanner_worker.go
│   └── test_utils.go
├── endpoint
│   ├── add_task.go
│   ├── endpoint.go
│   ├── get_task.go
│   ├── get_tasks.go
│   └── scan_task.go
├── go.mod
├── go.sum
├── helper
│   ├── middleware
│   │   ├── applicationlogging.go
│   │   ├── instrumentation.go
│   │   └── middleware.go
│   └── utils
│       └── utils.go
├── infrastructure
│   ├── github
│   │   └── github.go
│   ├── nats
│   │   └── nats.go
│   └── postgres
│       ├── dal_model.go
│       ├── migration.go
│       ├── postgres.go
│       ├── scanning_task.go
│       └── scanning_task_test.go
├── migrations
│   ├── 20220320_create_scanning_task_tables.down.sql
│   └── 20220320_create_scanning_task_tables.up.sql
├── my_project_structure.txt
└── transport
    ├── http
    │   └── http.go
    └── nats
        └── nats.go
```

#### Directory structure
**cmd**: The entry point of the application.

**domain**: Contains the business logic, including entities, value objects, services, repositories, and domain errors. The domain is the core of the application and should not depend on any other layer.

**domain/rules**: Contains the domain rules. In this case, it includes HardcodedSecretRule, which is an implementation of the Rule interface. These rules are used by the domain.ScannerService to scan the source code for vulnerabilities. It also includes unit tests for these rules to ensure their correctness. Any new rules added to the system should be added to this package. 

**endpoint**: Contains the implementation of GoKit endpoints that provide access to the domain layer.

**helper**: Contains reusable helper functions and utilities.
**infrastructure**: Contains implementation details for external services, databases, message queues, and other infrastructure-related functionality. This layer should be used to connect to the domain layer and translate its concepts into a language that infrastructure services can understand.

**migrations**: Contains database schema migration scripts.

**transport**: Contains the implementation of transport mechanisms for the application, such as HTTP, gRPC, and message queues.

#### 4.8 Testing Considerations
- Unit tests: Covering the core functionality with unit tests

### 5. Requests Pending
- Implement outbox event pattern to enhance the reliability of message delivery.

#### 5.1 Decision Log
| Index | Decision Required| Status    | Outcome             | Rationale                                   | Other Comments and Notes |
|-------|------------------|-----------|---------------------|---------------------------------------------|--------------------------|
| 1     | Message Queue Platform    | Decided   | NATS                | Support for high-throughput messaging with low latency and simple configuration  |                          |
| 2     | Deployment Platform       | In review | AWS and GCP         | Consider cost and scalability as integration with other services and ease of use ||
| 3     | Rule Engine      | Decided   | Manual Rule Engine  | Easy to customize and integrate with the vulnerability scanner for container images    |              |


### 6. Technology and Stack
Programming language: Golang
Message broker: NATS
Database: PostgreSQL
Framework: Gokit
Principle/Architecture: DDD/Clean Architecture.
Containerization: Docker
Orchestration: Docker Compose, Kubernetes

### 7. Local Setup
##### Install Docker and Docker Compose.
##### Clone this repository.
##### Fetch dependencies: `go mod tidy`.
##### Run test: `go test ./...`.
##### Start app: `docker-compose up --build`.
##### Access the API at [http://localhost:8080/vulnerability-scanner/v1/tasks](http://localhost:8080/vulnerability-scanner/v1/tasks).
