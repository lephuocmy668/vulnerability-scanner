// Package domain provides the use-case of vulnerability-scanner.
// Used by views facing the end-user.
package domain

import (
	"context"
	"errors"
	"fmt"
	"time"

	"github.com/google/uuid"
	"github.com/jinzhu/gorm"
	"github.com/lephuocmy668/vulnerability-scanner/helper/utils"

	"github.com/go-kit/kit/log"
	"github.com/go-kit/log/level"
)

// ScannerService is the interface that provides the basic Scanner methods.
type ScannerService interface {
	// Create store new task to the queue and
	// return the task info for tracking purpose
	CreateTask(request CreateTaskRequest) (*ScanningTask, error)

	// GetDetail returns the task info
	GetTaskDetail(id string) (*ScanningTask, error)

	// GetDetail returns the task info
	GetTasks(request GetTasksRequest) ([]ScanningTask, error)

	// Scan scans vulnerabilities base on task id
	Scan(taskID string, ctx context.Context) (result *ScanningTask, err error)
}

type scannerService struct {
	taskRepo             TaskRepository
	logger               log.Logger
	sourceCodeRepository SourceCodeRepository
	publisher            Publisher
	ruleList             []Rule
}

// NewService returns a new ScannerService.
func NewService(taskRepo TaskRepository, logger log.Logger, sourceCodeRepository SourceCodeRepository, publisher Publisher, ruleList []Rule) ScannerService {
	return &scannerService{
		taskRepo:             taskRepo,
		logger:               logger,
		sourceCodeRepository: sourceCodeRepository,
		publisher:            publisher,
		ruleList:             ruleList,
	}
}

// CreateTask creates a task, stores into db and return the task as a result.
func (s *scannerService) CreateTask(request CreateTaskRequest) (task *ScanningTask, err error) {
	now := time.Now()

	if !utils.IsValidGitHubRepoURL(request.RepositoryURL) {
		level.Error(s.logger).Log(
			"message", "invalid repository url",
			"repositoryName", request.RepositoryName,
			"repositoryURL", request.RepositoryURL,
		)
		return nil, ErrInvalidRepoURL
	}

	task, err = s.taskRepo.Create(ScanningTask{
		ID:             uuid.New().String(),
		Status:         TaskQueuedStatus,
		RepositoryName: request.RepositoryName,
		RepositoryURL:  request.RepositoryURL,
		Findings:       nil,
		CreatedAt:      &now,
		StartedAt:      nil,
		CompletedAt:    nil,
		Error:          "",
	})
	if err != nil {
		level.Error(s.logger).Log(
			"message", "create task detail failed",
			"error", err.Error(),
			"repositoryName", request.RepositoryName,
			"repositoryURL", request.RepositoryURL,
		)
		return nil, ErrInternalServer
	}

	if err = s.publisher.Publish(ScanningTaskCreatedTopic, task.ID); err != nil {
		level.Error(s.logger).Log(
			"message", "publish message failed",
			"error", err.Error(),
			"repositoryName", request.RepositoryName,
			"repositoryURL", request.RepositoryURL,
			"id", task.ID,
		)
		return
	}
	level.Info(s.logger).Log(
		"message", "publish message successfully",
		"id", task.ID,
	)

	return
}

// GetTaskDetail retrieves task base on taskID and returns a ScanningTask object
func (s *scannerService) GetTaskDetail(taskID string) (task *ScanningTask, err error) {
	if !utils.IsValidUUID(taskID) {
		return nil, ErrInvalidTaskID
	}

	task, err = s.taskRepo.FindOne(taskID)
	if err != nil {
		level.Error(s.logger).Log(
			"message", "get task detail failed",
			"error", err.Error(),
			"task_id", taskID,
		)
		if errors.Is(err, gorm.ErrRecordNotFound) {
			return nil, ErrTaskNotFound
		}

		return nil, ErrInternalServer
	}

	return
}

// GetTasks retrieves tasks base on criterias in GetTasksRequest and returns the slice of result.
func (s *scannerService) GetTasks(request GetTasksRequest) (result []ScanningTask, err error) {
	result, err = s.taskRepo.FindAll(request)
	if err != nil {
		level.Error(s.logger).Log(
			"message", "Get tasks failed",
			"error", err.Error(),
			"order_by_field", request.OrderByField,
			"order_by_direction", request.OrderByDirection,
			"Status", request.Status,
		)
		return nil, ErrInternalServer
	}

	return
}

// Scan scans vulnerabilities base on task id
func (s *scannerService) Scan(taskID string, ctx context.Context) (result *ScanningTask, err error) {
	ctx = context.WithValue(ctx, TaskIDContextType(TaskIDContextKey), taskID)
	level.Info(s.logger).Log(
		"message", "trigger scanning task",
		"task_id", taskID,
	)

	// retrieve the waiting task
	queuedTask, err := s.taskRepo.FindOne(taskID)
	if err != nil {
		level.Error(s.logger).Log(
			"message", "get task detail failed",
			"error", err.Error(),
			"task_id", taskID,
		)
		return nil, err
	}

	// mark task as inprogress
	inProgressTask, err := s.taskRepo.UpdateStatus(queuedTask.ID, TaskInProgressStatus)
	if err != nil {
		level.Error(s.logger).Log(
			"message", "mark task as in-progress failed",
			"error", err.Error(),
			"task_id", queuedTask.ID,
			"status", TaskInProgressStatus,
		)
		return nil, err
	}

	// extract git repo owner and repo name from url
	owner, repo, err := utils.ExtractOwnerAndRepoFromGithubURL(inProgressTask.RepositoryURL)
	if err != nil {
		level.Error(s.logger).Log(
			"message", "extract owner and repo from github url failed",
			"error", err.Error(),
			"repository_name", inProgressTask.RepositoryName,
			"repository_url", inProgressTask.RepositoryURL,
		)
		return nil, err
	}

	// scan github repo
	findings, err := s.scanFilesConcurrently(ctx, owner, repo)
	if err != nil {
		level.Error(s.logger).Log(
			"message", "scan failed",
			"error", err.Error(),
			"repository_name", inProgressTask.RepositoryName,
			"repository_url", inProgressTask.RepositoryURL,
		)

		scanningError := fmt.Errorf("Error had occured while scanning task: %s", err.Error())
		if err := s.taskRepo.MarkTaskAsFailed(inProgressTask.ID, findings, scanningError); err != nil {
			level.Error(s.logger).Log(
				"message", "error had occured while marking task as failed",
				"error", err.Error(),
				"task_id", inProgressTask.ID,
				"status", TaskFailureStatus,
			)
			return nil, err
		}

		return nil, err
	}

	// store vulnerabilities into db and mark task as success
	successTask, err := s.taskRepo.UpdateFindingsAndStatus(inProgressTask.ID, findings, TaskSuccessStatus)
	if err != nil {
		level.Error(s.logger).Log(
			"message", "update findings failed",
			"error", err.Error(),
			"task_id", inProgressTask.ID,
		)
		return nil, err
	}

	return successTask, err
}
