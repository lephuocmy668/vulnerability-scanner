package rules

import (
	"regexp"

	"github.com/lephuocmy668/vulnerability-scanner/domain"
)

// Find lines that start with public_key or private_key using regex.
var keyPatternRegex = regexp.MustCompile("(?m)^\\s*(public|private)_key")

// error description of hardcoded secret issue
const hardcodedSecretErrorDescription = "Hardcoded secret detected. It is not secure to store secrets directly in code. Please remove the secret or use a secure storage solution."

// Counting the number of lines in a string.
func countLines(s string) int {
	return len(regexp.MustCompile("\n").FindAllString(s, -1)) + 1
}

// hardcodedSecret implements github.com/lephuocmy668/vulnerability-scanner/domain.Rule
type hardcodedSecret struct {
	id string
}

// ID return id of the rule
func (issue *hardcodedSecret) ID() string {
	return issue.id
}

// Type returns rule type
func (issue *hardcodedSecret) Type() string {
	return domain.SAST
}

// Match validates content follow the rule
func (issue *hardcodedSecret) Match(fileContext string, fileContent *string) (result []domain.Vulnerability, err error) {
	matches := keyPatternRegex.FindAllStringIndex(*fileContent, -1)
	for _, match := range matches {
		vul := domain.NewVulnerability(
			issue,
			fileContext,
			countLines((*fileContent)[:match[0]]),
			domain.High,
			hardcodedSecretErrorDescription,
		)
		result = append(result, vul)
	}
	return
}

// NewHardcodedSecret builds a rule that detects hardcoded secret
func NewHardcodedSecret(id string) domain.Rule {
	return &hardcodedSecret{id: id}
}
