// Package domain provides the use-case of vulnerability-scanner.
// Used by views facing the end-user.
package domain

import (
	"context"
	"errors"
	"testing"

	"github.com/jinzhu/gorm"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/mock"
)

func Test_CreateTask_Success(t *testing.T) {
	// Create mock objects for the dependencies.
	taskRepo := &mockTaskRepo{}
	publisher := &mockMessagePublisher{}
	logger := &mockLogger{}

	// Create a scannerService object and pass in the mocked dependencies.
	s := &scannerService{
		taskRepo:  taskRepo,
		publisher: publisher,
		logger:    logger,
	}

	// Create a CreateTaskRequest object to pass into the CreateTask method.
	req := CreateTaskRequest{
		RepositoryName: "github.com/example/repo",
		RepositoryURL:  "https://github.com/example/repo",
	}

	// Set up the mock to return a ScanningTask object.
	task := &ScanningTask{
		ID:             "abc123",
		Status:         TaskQueuedStatus,
		RepositoryName: req.RepositoryName,
		RepositoryURL:  req.RepositoryURL,
		Findings:       nil,
		CreatedAt:      nil,
		StartedAt:      nil,
		CompletedAt:    nil,
		Error:          "",
	}
	taskRepo.On("Create", mock.Anything).Return(task, nil)

	// Set up the mock to return nil for the publisher's Publish method.
	publisher.On("Publish", mock.Anything, mock.Anything).Return(nil)

	// Set up the mock to return nil for the logger's Log method.
	logger.On("Log", mock.Anything).Return(nil)

	// Call the CreateTask method and check the result.
	result, err := s.CreateTask(req)
	if err != nil {
		t.Errorf("unexpected error: %v", err)
		return
	}
	if result == nil {
		t.Error("expected result to not be nil")
		return
	}
	if result.ID != task.ID {
		t.Errorf("expected ID to be %q but got %q", task.ID, result.ID)
	}
	// Check other values of the returned task here.

	// Assert that the expected methods were called on the mocks.
	taskRepo.AssertExpectations(t)
	publisher.AssertExpectations(t)
	logger.AssertExpectations(t)
}

func TestCreateTask_WithError(t *testing.T) {
	// Create a mock dependencies.
	taskRepo := &mockTaskRepo{}
	publisher := &mockMessagePublisher{}
	logger := &mockLogger{}

	// Create a scannerService object and pass in the mocked dependencies.
	s := &scannerService{
		taskRepo:  taskRepo,
		publisher: publisher,
		logger:    logger,
	}

	// Set up the mock.
	taskRepo.On("Create", mock.Anything).Return(&ScanningTask{}, errors.New("error creating task"))
	logger.On("Log", mock.Anything).Return(nil)

	// Create a CreateTaskRequest object to pass into the CreateTask method.
	req := CreateTaskRequest{
		RepositoryName: "github.com/example/repo",
		RepositoryURL:  "https://github.com/example/repo",
	}

	// Call the CreateTask method and check the error.
	_, err := s.CreateTask(req)
	if err == nil {
		t.Error("expected error but got nil")
		return
	}
	if err != ErrInternalServer {
		t.Errorf("expected error to be %v but got %v", ErrInternalServer, err)
	}

	// Assert that the expected methods were called on the mock.
	taskRepo.AssertExpectations(t)
}

func TestCreateTask_WithInValidRepoURL(t *testing.T) {
	// Create a mock dependencies.
	taskRepo := &mockTaskRepo{}
	publisher := &mockMessagePublisher{}
	logger := &mockLogger{}

	// Set up the mock.
	logger.On("Log", mock.Anything).Return(nil)

	// Create a scannerService object and pass in the mocked dependencies.
	s := &scannerService{
		taskRepo:  taskRepo,
		publisher: publisher,
		logger:    logger,
	}

	request := CreateTaskRequest{
		RepositoryName: "invalid-repo",
		RepositoryURL:  "invalid-repo-url",
	}
	task, err := s.CreateTask(request)

	if task != nil || err != ErrInvalidRepoURL {
		t.Errorf("Expected error: %v, but got: %v", ErrInvalidRepoURL, err)
	}
}

func TestGetTaskDetail_Success(t *testing.T) {

	// Create a scannerService object and pass in the necessary dependencies.
	taskRepo := &mockTaskRepo{}
	publisher := &mockMessagePublisher{}
	logger := &mockLogger{}

	s := &scannerService{
		taskRepo:  taskRepo,
		publisher: publisher,
		logger:    logger,
	}

	// Set up the mock to return a ScanningTask object.
	task := &ScanningTask{
		ID:             "2a1173a8-c79a-4577-a790-2c143fd6a4ba",
		Status:         TaskQueuedStatus,
		RepositoryName: "github.com/example/repo",
		RepositoryURL:  "https://github.com/example/repo",
		Findings:       nil,
		CreatedAt:      nil,
		StartedAt:      nil,
		CompletedAt:    nil,
		Error:          "",
	}
	taskRepo.On("FindOne", "2a1173a8-c79a-4577-a790-2c143fd6a4ba").Return(task, nil)

	// Call the GetTaskDetail method and check the result.
	result, err := s.GetTaskDetail("2a1173a8-c79a-4577-a790-2c143fd6a4ba")
	if err != nil {
		t.Errorf("unexpected error: %v", err)
		return
	}
	if result == nil {
		t.Error("expected result to not be nil")
		return
	}
	if result.ID != task.ID {
		t.Errorf("expected ID to be %q but got %q", task.ID, result.ID)
	}
}

func TestGetTaskDetail_NotFound(t *testing.T) {
	// Create a scannerService object and pass in the necessary dependencies.
	taskRepo := &mockTaskRepo{}
	publisher := &mockMessagePublisher{}
	logger := &mockLogger{}

	s := &scannerService{
		taskRepo:  taskRepo,
		publisher: publisher,
		logger:    logger,
	}

	// Set up the mock.
	taskRepo.On("FindOne", "2a1173a8-c79a-4577-a790-2c143fd6a4ba").Return(&ScanningTask{}, gorm.ErrRecordNotFound)
	logger.On("Log", mock.Anything).Return(nil)

	// Call the GetTaskDetail method with non existing task ID and check the error.
	_, err := s.GetTaskDetail("2a1173a8-c79a-4577-a790-2c143fd6a4ba")
	if err != ErrTaskNotFound {
		t.Errorf("expected error to be %v but got %v", ErrTaskNotFound, err)
	}
}

func TestGetTaskDetail_WithUnexpectedError(t *testing.T) {
	// Create a scannerService object and pass in the necessary dependencies.
	taskRepo := &mockTaskRepo{}
	publisher := &mockMessagePublisher{}
	logger := &mockLogger{}

	s := &scannerService{
		taskRepo:  taskRepo,
		publisher: publisher,
		logger:    logger,
	}

	// Set up the mock.
	unexpectedError := errors.New("some thing")
	taskRepo.On("FindOne", "2a1173a8-c79a-4577-a790-2c143fd6a4ba").Return(&ScanningTask{}, unexpectedError)
	logger.On("Log", mock.Anything).Return(nil)

	// Call the GetTaskDetail method with non existing task ID and check the error.
	_, err := s.GetTaskDetail("2a1173a8-c79a-4577-a790-2c143fd6a4ba")
	if err != ErrInternalServer {
		t.Errorf("expected error to be %v but got %v", ErrInternalServer, err)
	}
}

func TestGetTasks_Success(t *testing.T) {
	// set up
	taskRepo := &mockTaskRepo{}
	task1 := ScanningTask{ID: "task1", Status: TaskQueuedStatus}
	task2 := ScanningTask{ID: "task2", Status: TaskQueuedStatus}
	taskList := []ScanningTask{task1, task2}

	taskRepo.On("FindAll", mock.AnythingOfType("GetTasksRequest")).Return(taskList, nil)

	scannerService := &scannerService{taskRepo: taskRepo}

	// test
	request := GetTasksRequest{Status: TaskQueuedStatus}
	result, err := scannerService.GetTasks(request)

	// assert
	assert.NoError(t, err)
	assert.Equal(t, taskList, result)
}

func TestGetTasks_Failure(t *testing.T) {
	// set up
	logger := &mockLogger{}
	taskRepo := &mockTaskRepo{}
	taskRepo.On("FindAll", mock.Anything).Return([]ScanningTask{}, errors.New("something went wrong"))
	logger.On("Log", mock.Anything).Return(nil)

	scannerService := &scannerService{taskRepo: taskRepo, logger: logger}

	// test
	request := GetTasksRequest{Status: TaskQueuedStatus}
	result, err := scannerService.GetTasks(request)

	// assert
	assert.Error(t, err)
	assert.Nil(t, result)
	if err != ErrInternalServer {
		t.Errorf("expected error to be %v but got %v", ErrInternalServer, err)
	}
}

func TestScan_Success(t *testing.T) {
	// set up test data
	vul := Vulnerability{}
	taskID := "2a1173a8-c79a-4577-a790-2c143fd6a4ba"
	fileContent := "fileContent"
	mockQueuedTask := ScanningTask{
		ID:             taskID,
		Status:         TaskQueuedStatus,
		RepositoryName: "test-repo",
		RepositoryURL:  "https://github.com/lephuocmy668/test-repo",
		Findings:       nil,
		CreatedAt:      nil,
		StartedAt:      nil,
		CompletedAt:    nil,
		Error:          "",
	}
	mockSuccessTask := ScanningTask{
		ID:             taskID,
		Status:         TaskSuccessStatus,
		RepositoryName: "test-repo",
		RepositoryURL:  "https://github.com/lephuocmy668/test-repo",
		Findings:       []Vulnerability{vul},
		CreatedAt:      nil,
		StartedAt:      nil,
		CompletedAt:    nil,
		Error:          "",
	}

	// set up mock objects
	mockTaskRepo := &mockTaskRepo{}
	mockSourceCodeRepo := &mockSourceCodeRepo{}
	mockPublisher := &mockMessagePublisher{}
	mockHardcodedSecretRule := &mockRule{}
	mockLogger := &mockLogger{}
	mockRules := []Rule{
		mockHardcodedSecretRule,
	}
	mockLogger.On("Log", mock.Anything).Return(nil)

	scannerService := &scannerService{
		taskRepo:             mockTaskRepo,
		sourceCodeRepository: mockSourceCodeRepo,
		logger:               mockLogger,
		publisher:            mockPublisher,
		ruleList:             mockRules,
	}
	ctx := context.Background()

	mockTaskRepo.On("FindOne", taskID).Return(&mockQueuedTask, nil)
	mockTaskRepo.On("UpdateStatus", mockQueuedTask.ID, TaskInProgressStatus).Return(&mockQueuedTask, nil)
	mockTaskRepo.On("UpdateFindingsAndStatus", mockQueuedTask.ID, mock.Anything, TaskSuccessStatus).Return(&mockSuccessTask, nil)
	mockSourceCodeRepo.On(
		"GetContents",
		mock.Anything,
		"lephuocmy668",
		"test-repo",
		mock.Anything,
		mock.Anything,
	).Return([]GitContent{{Type: "file", Path: "main.go"}}, nil)
	mockSourceCodeRepo.On(
		"GetContent",
		mock.Anything,
		"lephuocmy668",
		"test-repo",
		"main.go",
	).Return(&fileContent, nil)
	mockHardcodedSecretRule.On(
		"Match",
		"main.go",
		&fileContent,
	).Return([]Vulnerability{vul}, nil)

	result, err := scannerService.Scan(taskID, ctx)
	assert.NoError(t, err)
	assert.NotNil(t, result)

	// assert that the task was marked as success
	assert.Equal(t, TaskSuccessStatus, result.Status)

	// assert that the findings were populated
	assert.NotNil(t, result.Findings)
	assert.Equal(t, 1, len(result.Findings))
}

func TestScan_WithScanError(t *testing.T) {
	// set up test data
	vul := Vulnerability{}
	taskID := "2a1173a8-c79a-4577-a790-2c143fd6a4ba"
	fileContent := "fileContent"
	mockQueuedTask := ScanningTask{
		ID:             taskID,
		Status:         TaskQueuedStatus,
		RepositoryName: "test-repo",
		RepositoryURL:  "https://github.com/lephuocmy668/test-repo",
		Findings:       nil,
		CreatedAt:      nil,
		StartedAt:      nil,
		CompletedAt:    nil,
		Error:          "",
	}

	// set up mock objects
	mockTaskRepo := &mockTaskRepo{}
	mockSourceCodeRepo := &mockSourceCodeRepo{}
	mockPublisher := &mockMessagePublisher{}
	mockHardcodedSecretRule := &mockRule{}
	mockLogger := &mockLogger{}
	mockRules := []Rule{
		mockHardcodedSecretRule,
	}
	mockLogger.On("Log", mock.Anything).Return(nil)

	scannerService := &scannerService{
		taskRepo:             mockTaskRepo,
		sourceCodeRepository: mockSourceCodeRepo,
		logger:               mockLogger,
		publisher:            mockPublisher,
		ruleList:             mockRules,
	}
	ctx := context.Background()

	mockTaskRepo.On("FindOne", taskID).Return(&mockQueuedTask, nil)
	mockTaskRepo.On("UpdateStatus", mockQueuedTask.ID, TaskInProgressStatus).Return(&mockQueuedTask, nil)
	mockTaskRepo.On("MarkTaskAsFailed", mock.Anything, mock.Anything, mock.Anything).Return(nil)
	mockSourceCodeRepo.On(
		"GetContents",
		mock.Anything,
		"lephuocmy668",
		"test-repo",
		mock.Anything,
		mock.Anything,
	).Return([]GitContent{{Type: "file", Path: "main.go"}}, nil)
	mockSourceCodeRepo.On(
		"GetContent",
		mock.Anything,
		"lephuocmy668",
		"test-repo",
		"main.go",
	).Return(&fileContent, nil)
	somethingWentWrongErr := errors.New("something went wrong")
	mockHardcodedSecretRule.On(
		"Match",
		"main.go",
		&fileContent,
	).Return([]Vulnerability{vul}, somethingWentWrongErr)

	_, err := scannerService.Scan(taskID, ctx)
	assert.NotNil(t, err)
}
