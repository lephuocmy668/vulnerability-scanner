package domain

import (
	"context"
	"fmt"
	"sync"

	"github.com/go-kit/log/level"
)

const (
	// workerCount is number of workers for spawn
	// TODO: move to config
	workerCount = 5
)

// scannerWorker is method to perform scanning on a specific file path or directory
// by using concurrent workers. The method reads the paths from the input channel,
// retrieves the file contents or sub-directories from the Git repository,
// and executes the scanning rules on the contents of each file.
// The function sends the detected vulnerabilities to the output channel.
func (s *scannerService) scannerWorker(ctx context.Context, owner string, repo string, jobs chan string, results chan<- Vulnerability, errChan chan<- error, wg *sync.WaitGroup) {
	taskID := ctx.Value(TaskIDContextType(TaskIDContextKey))

	for path := range jobs {
		contents, err := s.sourceCodeRepository.GetContents(ctx, owner, repo, path)
		if err != nil {
			level.Error(s.logger).Log(
				"message", "Get git contents failed",
				"error", err.Error(),
				"task_id", taskID,
			)
			errChan <- fmt.Errorf("Get git contents failed, task_id: %s, path: %s, err: %s", taskID, path, err.Error())
			wg.Done()
			return
		}

		for _, content := range contents {
			if content.Type == "dir" {
				wg.Add(1)
				job := content.Path
				go func() {
					jobs <- job
				}()

			} else if content.Type == "file" {
				level.Info(s.logger).Log(
					"message", fmt.Sprintf("scanning file %s", content.Path),
					"task_id", taskID,
				)

				fileContent, err := s.sourceCodeRepository.GetContent(ctx, owner, repo, content.Path)
				if err != nil {
					errChan <- fmt.Errorf("Get git content failed, taskID: %s, path: %s, err: %s", taskID, path, err.Error())
					wg.Done()
					return
				}

				for _, rule := range s.ruleList {
					vulnerabilities, err := rule.Match(content.Path, fileContent)
					if err != nil {
						errChan <- fmt.Errorf("Scan git content failed, taskID: %s, path: %s, err: %s", taskID, content.Path, err.Error())
						wg.Done()
						return
					}

					for _, item := range vulnerabilities {
						results <- item
					}
				}
			}
		}

		wg.Done()
	}
}

// scanFilesConcurrently is method to scan the entire Git repository by using multiple scannerWorker concurrently.
// The method initializes the worker channels, creates a specific number of scannerWorkers, and waits until all
// scannerWorkers have completed their tasks. The method returns a slice of vulnerabilities detected by scanning the Git repository.
func (s *scannerService) scanFilesConcurrently(ctx context.Context, owner string, repo string) (findings []Vulnerability, err error) {
	taskID := ctx.Value(TaskIDContextType(TaskIDContextKey))

	done := make(chan bool)
	defer close(done)
	result := make(chan Vulnerability, workerCount)
	defer close(result)
	jobs := make(chan string, workerCount)
	defer close(jobs)
	errChannel := make(chan error, workerCount)
	defer close(errChannel)

	wg := &sync.WaitGroup{}
	for i := 0; i < workerCount; i++ {
		go s.scannerWorker(ctx, owner, repo, jobs, result, errChannel, wg)
	}

	wg.Add(1)
	go func() {
		jobs <- ""
	}()

	go func() {
		wg.Wait()
		done <- true
	}()

readloop:
	for {
		select {
		case err = <-errChannel:
			level.Error(s.logger).Log(
				"message", fmt.Sprintf("Error had occured when scan files concurrently, err: %s", err.Error()),
				"task_id", taskID,
			)
		case finding := <-result:
			findings = append(findings, finding)
		case <-done:
			break readloop
		}
	}

	return
}
