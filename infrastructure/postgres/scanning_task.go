// The package postgres provides implementation for persisting scanning task data and related entities into PostgreSQL database.
package postgres

import (
	"time"

	"github.com/jinzhu/gorm"
	domain "github.com/lephuocmy668/vulnerability-scanner/domain"
)

type taskRepository struct {
	db *gorm.DB
}

func NewTaskRepository(db *gorm.DB) domain.TaskRepository {
	return &taskRepository{db: db}
}

func (r *taskRepository) Create(task domain.ScanningTask) (*domain.ScanningTask, error) {
	gormTask := initScanningTaskFromDomainScanningTask(task)
	if err := r.db.Create(&gormTask).Error; err != nil {
		return nil, err
	}

	return gormTask.toDomainScanningTask(), nil
}

func (r *taskRepository) FindOne(id string) (*domain.ScanningTask, error) {

	var task ScanningTask
	if err := r.db.Where("id = ?", id).Preload("Findings").First(&task).Error; err != nil {
		return nil, err
	}

	return task.toDomainScanningTask(), nil
}

func (r *taskRepository) FindAll(request domain.GetTasksRequest) (result []domain.ScanningTask, err error) {
	var tasks []ScanningTask

	query := r.db.Preload("Findings")

	if request.Status != "" {
		query = query.Where("status = ?", request.Status)
	}
	if request.RepositoryName != "" {
		query = query.Where("repository_name = ?", request.RepositoryName)
	}

	orderByField := "created_at"
	direction := "desc"
	if request.OrderByField != "" {
		orderByField = request.OrderByField
	}
	if request.OrderByDirection != "" {
		direction = request.OrderByDirection
	}
	query = query.Order(orderByField + " " + direction)

	if err := query.Find(&tasks).Error; err != nil {
		return nil, err
	}

	for _, item := range tasks {
		result = append(result, *item.toDomainScanningTask())
	}

	return
}

func (r *taskRepository) UpdateStatus(id string, status string) (*domain.ScanningTask, error) {
	var task ScanningTask
	if err := r.db.Model(&domain.ScanningTask{}).Where("id = ?", id).Update("status", status).First(&task).Error; err != nil {
		return nil, err
	}
	return task.toDomainScanningTask(), nil
}

func (r *taskRepository) MarkTaskAsFailed(id string, findings []domain.Vulnerability, errIn error) error {
	var now = time.Now()
	var task ScanningTask
	if err := r.db.Where("id = ?", id).Preload("Findings").First(&task).Error; err != nil {
		return err
	}

	// Update status, error, completed_at
	task.Status = domain.TaskFailureStatus
	task.Error = errIn.Error()
	task.CompletedAt = &now

	// Replace the findings with the new list
	for _, item := range findings {
		task.Findings = append(task.Findings, Vulnerability{
			RuleID:         item.RuleID,
			ScanningTaskID: id,
			Type:           item.Type,
			Location: FileLocation{
				Path: item.Location.Path,
				Begin: FileLocationPoint{
					Line: item.Location.Begin.Line,
				},
			},
			VulnerabilityMetadata: VulnerabilityMetadata{
				Description: item.Metadata.Description,
				Severity:    item.Metadata.Severity,
			},
		})
	}

	return r.db.Save(&task).Error
}

func (r *taskRepository) UpdateFindingsAndStatus(id string, findings []domain.Vulnerability, status string) (*domain.ScanningTask, error) {
	var now = time.Now()
	var task ScanningTask
	if err := r.db.Where("id = ?", id).Preload("Findings").First(&task).Error; err != nil {
		return nil, err
	}

	// Update status
	task.Status = domain.TaskSuccessStatus
	task.CompletedAt = &now

	// Replace the findings with the new list
	for _, item := range findings {
		task.Findings = append(task.Findings, Vulnerability{
			RuleID:         item.RuleID,
			ScanningTaskID: id,
			Type:           item.Type,
			Location: FileLocation{
				Path: item.Location.Path,
				Begin: FileLocationPoint{
					Line: item.Location.Begin.Line,
				},
			},
			VulnerabilityMetadata: VulnerabilityMetadata{
				Description: item.Metadata.Description,
				Severity:    item.Metadata.Severity,
			},
		})
	}

	if err := r.db.Save(&task).Error; err != nil {
		return nil, err
	}

	return task.toDomainScanningTask(), nil
}
