package postgres

import (
	"errors"
	"regexp"
	"testing"

	"github.com/DATA-DOG/go-sqlmock"
	"github.com/jinzhu/gorm"
	"github.com/lephuocmy668/vulnerability-scanner/domain"
	"github.com/stretchr/testify/require"
)

func TestCreate_Success(t *testing.T) {
	// Set up mock database and repository
	db, mock, err := sqlmock.New()
	require.NoError(t, err)
	defer db.Close()

	gormDB, err := gorm.Open("postgres", db)
	require.NoError(t, err)
	defer gormDB.Close()

	repo := NewTaskRepository(gormDB)

	// Set up test data
	task := domain.ScanningTask{
		ID:             "ID",
		Status:         "Queued",
		RepositoryName: "RepositoryName",
		RepositoryURL:  "RepositoryURL",
	}

	// Mock database queries
	mock.ExpectBegin()
	mock.ExpectQuery(regexp.QuoteMeta(
		`INSERT INTO "scanning_tasks" ("id","status","repository_name","repository_url","error","created_at","completed_at","updated_at","started_at","deleted_at") VALUES ($1,$2,$3,$4,$5,$6,$7,$8,$9,$10) RETURNING "scanning_tasks"."id"`)).
		WithArgs(task.ID, task.Status, task.RepositoryName, task.RepositoryURL, task.Error, sqlmock.AnyArg(), sqlmock.AnyArg(), sqlmock.AnyArg(), sqlmock.AnyArg(), sqlmock.AnyArg()).
		WillReturnRows(sqlmock.NewRows([]string{task.ID}).AddRow(task.ID))
	mock.ExpectCommit()

	// Call the method being tested
	result, err := repo.Create(task)

	// Assert the result is as expected
	require.NoError(t, err)
	require.Equal(t, task.ID, result.ID)

	// Assert the mock database expectations were met
	require.NoError(t, mock.ExpectationsWereMet())
}

func TestCreate_WithError(t *testing.T) {
	mockDB, mock, err := sqlmock.New()
	require.NoError(t, err)
	defer mockDB.Close()

	db, err := gorm.Open("postgres", mockDB)
	require.NoError(t, err)
	defer db.Close()

	repo := NewTaskRepository(db)

	task := domain.ScanningTask{
		ID:             "ID",
		Status:         "Queued",
		RepositoryName: "RepositoryName",
		RepositoryURL:  "RepositoryURL",
	}
	expectedError := errors.New("some error")

	mock.ExpectBegin()
	mock.ExpectQuery(regexp.QuoteMeta(
		`INSERT INTO "scanning_tasks" ("id","status","repository_name","repository_url","error","created_at","completed_at","updated_at","started_at","deleted_at") VALUES ($1,$2,$3,$4,$5,$6,$7,$8,$9,$10) RETURNING "scanning_tasks"."id"`)).
		WithArgs(task.ID, task.Status, task.RepositoryName, task.RepositoryURL, task.Error, sqlmock.AnyArg(), sqlmock.AnyArg(), sqlmock.AnyArg(), sqlmock.AnyArg(), sqlmock.AnyArg()).
		WillReturnError(expectedError)
	mock.ExpectRollback()

	result, err := repo.Create(task)

	require.Error(t, err)
	require.Contains(t, err.Error(), expectedError.Error())
	require.Nil(t, result)

	require.NoError(t, mock.ExpectationsWereMet())
}

func TestFindOne_Success(t *testing.T) {
	// Set up mock database and repository
	db, mock, err := sqlmock.New()
	require.NoError(t, err)
	defer db.Close()

	gormDB, err := gorm.Open("postgres", db)
	require.NoError(t, err)
	defer gormDB.Close()

	repo := NewTaskRepository(gormDB)

	// Set up test data
	id := "some-id"
	task := &ScanningTask{
		ID:             id,
		Status:         "Queued",
		RepositoryName: "RepositoryName",
		RepositoryURL:  "RepositoryURL",
	}
	vulnerability := Vulnerability{}

	// Mock database queries
	taskRows := sqlmock.NewRows([]string{"id", "status", "repository_name", "repository_url"}).
		AddRow(task.ID, task.Status, task.RepositoryName, task.RepositoryURL)
	mock.ExpectQuery(regexp.QuoteMeta(
		`SELECT * FROM "scanning_tasks" WHERE "scanning_tasks"."deleted_at" IS NULL AND ((id = $1)) ORDER BY "scanning_tasks"."id" ASC LIMIT 1`)).
		WithArgs(id).
		WillReturnRows(taskRows)

	vulnerabilitiesRows := sqlmock.NewRows([]string{"type", "rule_id", "path", "line", "description", "severity"}).
		AddRow(vulnerability.Type, vulnerability.RuleID, vulnerability.Location.Path, vulnerability.Location.Begin.Line, vulnerability.VulnerabilityMetadata.Description, vulnerability.VulnerabilityMetadata.Severity)
	mock.ExpectQuery(regexp.QuoteMeta(
		`SELECT * FROM "vulnerabilities" WHERE "vulnerabilities"."deleted_at" IS NULL AND (("scanning_task_id" IN ($1))) ORDER BY "vulnerabilities"."id" ASC`)).
		WithArgs(id).
		WillReturnRows(vulnerabilitiesRows)

	// Call the method being tested
	result, err := repo.FindOne(id)
	require.NoError(t, err)

	// Assert the result is as expected
	expected := &domain.ScanningTask{
		ID:             id,
		Status:         task.Status,
		RepositoryName: task.RepositoryName,
		RepositoryURL:  task.RepositoryURL,
		Findings:       []domain.Vulnerability{vulnerability.toDomainVulnerability()},
	}
	require.Equal(t, expected, result)

	// Assert the mock database expectations were met
	require.NoError(t, mock.ExpectationsWereMet())
}

func TestFindOne_NotFound(t *testing.T) {
	// Set up mock database and repository
	db, mock, err := sqlmock.New()
	require.NoError(t, err)
	defer db.Close()

	gormDB, err := gorm.Open("postgres", db)
	require.NoError(t, err)
	defer gormDB.Close()

	repo := NewTaskRepository(gormDB)

	// Set up test data
	id := "some-id"

	// Mock database query
	rows := sqlmock.NewRows([]string{})
	mock.ExpectQuery(regexp.QuoteMeta(
		`SELECT * FROM "scanning_tasks" WHERE "scanning_tasks"."deleted_at" IS NULL AND ((id = $1)) ORDER BY "scanning_tasks"."id" ASC LIMIT 1`)).
		WithArgs(id).
		WillReturnRows(rows)

	// Call the method being tested
	result, err := repo.FindOne(id)

	// Assert an error is returned
	require.Error(t, err)
	require.Contains(t, err.Error(), "record not found")
	require.Nil(t, result)

	// Assert the mock database expectations were met
	require.NoError(t, mock.ExpectationsWereMet())
}

func TestFindAll_Success(t *testing.T) {
	// Set up mock database and repository
	db, mock, err := sqlmock.New()
	require.NoError(t, err)
	defer db.Close()

	gormDB, err := gorm.Open("postgres", db)
	require.NoError(t, err)
	defer gormDB.Close()

	repo := NewTaskRepository(gormDB)

	// Set up test data
	id1 := "id1"
	id2 := "id2"
	task1 := &ScanningTask{
		ID:             id1,
		Status:         "Queued",
		RepositoryName: "RepositoryName",
		RepositoryURL:  "RepositoryURL",
	}
	task2 := &ScanningTask{
		ID:             id2,
		Status:         "Completed",
		RepositoryName: "RepositoryName",
		RepositoryURL:  "RepositoryURL",
	}
	vulnerability1 := Vulnerability{
		ID:             "1",
		ScanningTaskID: id1,
		Type:           "SAST",
		RuleID:         "RuleID1",
	}
	vulnerability2 := Vulnerability{
		ID:             "2",
		ScanningTaskID: id2,
		Type:           "SAST",
		RuleID:         "RuleID1",
	}
	request := domain.GetTasksRequest{
		Status:           "status",
		RepositoryName:   task1.RepositoryName,
		OrderByField:     "created_at",
		OrderByDirection: "desc",
	}

	// Mock database queries
	taskRows := sqlmock.NewRows([]string{"id", "status", "repository_name", "repository_url"}).
		AddRow(task1.ID, task1.Status, task1.RepositoryName, task1.RepositoryURL).
		AddRow(task2.ID, task2.Status, task2.RepositoryName, task2.RepositoryURL)
	mock.ExpectQuery(regexp.QuoteMeta(
		`SELECT * FROM "scanning_tasks" WHERE "scanning_tasks"."deleted_at" IS NULL AND ((status = $1) AND (repository_name = $2)) ORDER BY created_at desc`)).
		WithArgs(request.Status, task1.RepositoryName).
		WillReturnRows(taskRows)

	vulnerabilitiesRows := sqlmock.NewRows([]string{"scanning_task_id", "type", "rule_id", "path", "line", "description", "severity"}).
		AddRow(vulnerability1.ScanningTaskID, vulnerability1.Type, vulnerability1.RuleID, vulnerability1.Location.Path, vulnerability1.Location.Begin.Line, vulnerability1.VulnerabilityMetadata.Description, vulnerability1.VulnerabilityMetadata.Severity).
		AddRow(vulnerability2.ScanningTaskID, vulnerability2.Type, vulnerability2.RuleID, vulnerability2.Location.Path, vulnerability2.Location.Begin.Line, vulnerability2.VulnerabilityMetadata.Description, vulnerability2.VulnerabilityMetadata.Severity)
	mock.ExpectQuery(regexp.QuoteMeta(
		`SELECT * FROM "vulnerabilities" WHERE "vulnerabilities"."deleted_at" IS NULL AND (("scanning_task_id" IN ($1,$2)))`)).
		WithArgs(id1, id2).
		WillReturnRows(vulnerabilitiesRows)

	// Call the method being tested
	result, err := repo.FindAll(request)
	require.NoError(t, err)

	// Assert the result is as expected
	expected := []domain.ScanningTask{
		{
			ID:             id1,
			Status:         task1.Status,
			RepositoryName: task1.RepositoryName,
			RepositoryURL:  task1.RepositoryURL,
			Findings:       []domain.Vulnerability{vulnerability1.toDomainVulnerability()},
		},
		{
			ID:             id2,
			Status:         task2.Status,
			RepositoryName: task2.RepositoryName,
			RepositoryURL:  task2.RepositoryURL,
			Findings:       []domain.Vulnerability{vulnerability2.toDomainVulnerability()},
		},
	}
	require.Equal(t, expected, result)

	// Assert the mock database expectations were met
	require.NoError(t, mock.ExpectationsWereMet())
}

func TestFindAll_WithError(t *testing.T) {
	// Set up mock database and repository
	db, mock, err := sqlmock.New()
	require.NoError(t, err)
	defer db.Close()

	gormDB, err := gorm.Open("postgres", db)
	require.NoError(t, err)
	defer gormDB.Close()

	repo := NewTaskRepository(gormDB)

	// Set up test data
	request := domain.GetTasksRequest{
		Status:           "status",
		RepositoryName:   "repository_name",
		OrderByField:     "created_at",
		OrderByDirection: "desc",
	}

	expectedError := errors.New("some error")
	mock.ExpectQuery(regexp.QuoteMeta(
		`SELECT * FROM "scanning_tasks" WHERE "scanning_tasks"."deleted_at" IS NULL AND ((status = $1) AND (repository_name = $2)) ORDER BY created_at desc`)).
		WithArgs(request.Status, request.RepositoryName).
		WillReturnError(expectedError)

	// Call the method being tested
	result, err := repo.FindAll(request)

	// Assert the mock database expectations were met
	require.NoError(t, mock.ExpectationsWereMet())
	require.Nil(t, result)
}
